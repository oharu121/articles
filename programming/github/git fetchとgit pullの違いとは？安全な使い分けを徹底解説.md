## git fetch と git pull の違いとは？安全な使い分けを徹底解説

## はじめに

リモートリポジトリ（GitHub など）の最新の変更をローカル環境に持ってきたいとき、`git fetch` と `git pull` という 2 つのコマンドがあります。これらは似ていますが、動作が大きく異なります。

安全な開発フローのためには、この違いを正しく理解し、適切に使い分けることが不可欠です。この記事では、それぞれのコマンドの動きと最適な利用シーンを、図解を交えて解説します。

**違いを一言で**

まず結論から。2 つのコマンドの最も大きな違いは **「取得した変更を、すぐに作業ブランチに反映するかどうか」** です。

> - `git fetch`: **取得するだけ。** リモートの最新情報をダウンロードするが、現在の作業には影響を与えない。
> - `git pull`: **取得して、統合する。** 最新情報をダウンロードし、即座に現在の作業ブランチにマージする。

## 1. `git fetch` の動き：見るだけ、触らない

`git fetch` を実行すると、リモートリポジトリの最新のコミット情報をダウンロードし、**リモート追跡ブランチ**（`origin/main`など）を更新します。

重要なのは、**あなたの作業ブランチ（`main`など）には一切変更を加えない**という点です。

**【図解：fetch の前後】**

> - **実行前**: ローカルの `main` と `origin/main` は同じコミットを指している。

    ```
      A---B (main, origin/main)
    ```

> - **`git fetch` 実行後**: リモートで C が追加されていた場合、`origin/main` だけが C に進む。作業中の`main`は B のまま。

    ```
      A---B (main)
           \
            C (origin/main)
    ```

この「作業ブランチに影響を与えずに差分を確認できる」状態が、`fetch` の最大のメリットです。`git diff main origin/main` を実行すれば、取り込む前に変更内容をレビューできます。

## 2. `git pull` の動き：取ってきて、混ぜ込む

`git pull` は、内部的に **`git fetch` と `git merge` を一括で行う**コマンドです。

最新情報をダウンロードした後、その内容を現在の作業ブランチに自動でマージします。

**【図解：pull の前後】**

> - **実行前**:

    ```
      A---B (main)
           \
            C (origin/main)
    ```

> - **`git pull` 実行後**: `origin/main` の内容が `main` にマージされ、新しい **マージコミット（D）** が作られる。作業ブランチが直接更新される。

    ```
      A---B---D (main)
           \ /
            C (origin/main)
    ```

**💡 `git pull --rebase` という選択肢**

`pull` はデフォルトで `merge` を行いますが、`rebase` を使うこともできます。

```bash
git pull --rebase
```

これを実行すると、`fetch` の後に `merge` ではなく `rebase` が行われ、マージコミットが作られずに履歴が一直線に保たれます。チーム開発ではこちらの利用が推奨されることが多いです。

## 結局、どっちをいつ使うべき？

#### 🧐 `git fetch` を使うべきシナリオ

`fetch` は、より慎重で丁寧な操作が求められる場面で活躍します。

> - **リモートの変更内容を、自分の作業に影響を与えずに確認したいとき。**
>   →「main ブランチにどんな変更が入ったか、とりあえず見てみたい」
> - **PR（Pull Request）を出す前に、`main` との差分を確認したいとき。**
> - **履歴をきれいに保つため `rebase` を使いたいとき。（推奨）**
>   →`fetch` してから `rebase` するのが、最も安全でクリーンなワークフローです。

#### 🚀 `git pull` を使うべきシナリオ

`pull` は、とにかく素早く最新の状態に更新したい場合に便利です。

> - **他の誰も作業していない個人ブランチで、最新の `main` を手早く取り込みたいとき。**
> - **マージコミットが残っても構わない、小規模なプロジェクトや個人開発。**

**結論：チーム開発での推奨ワークフロー**

共同開発において、意図しない変更やコンフリクトを避け、クリーンな履歴を保つためには、以下の **「`fetch` → `rebase`」** のフローが最も安全で確実です。

> 1.  **まず`fetch`で、安全に最新情報を取得**

    ```bash
    git fetch origin
    ```

> 2.  **（任意）差分を確認**

    ```bash
    git diff main origin/main
    ```

> 3.  **`rebase`で、自分の変更を最新版の上に移動**

    ```bash
    git rebase origin/main
    ```

この手順を踏むことで、常に最新の状態で安心して開発を進めることができます。

**要点**:

> - **安全第一なら `fetch`**。差分を確認してから統合できる。
> - **手早く済ませたいなら `pull`**。ただし、意図せず作業ブランチが更新されるリスクを理解する。
