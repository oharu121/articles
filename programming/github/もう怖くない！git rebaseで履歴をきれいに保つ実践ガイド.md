## もう怖くない！git rebase で履歴をきれいに保つ実践ガイド

## はじめに

複数人での開発中、自分の作業ブランチを `main` ブランチの最新状態に追従させたい場面は頻繁にあります。そのための強力なコマンドが `git rebase` です。

「`git merge` と何が違うの？」
「履歴が書き換わるって聞いたけど、怖くて使えない…」

そんな方のために、この記事では `git rebase` を**なぜ・いつ使い、どう安全に運用するのか**を、図解を交えて分かりやすく解説します。

## なぜ `merge` ではなく `rebase` を使うのか？

`main` ブランチから自分の作業ブランチ（`feature`）を切り、作業を進めている間に、他の人の変更が `main` に取り込まれたとします。

```
  A---B---C---F (main)
   \
    D---E (feature)
```

このとき、`feature` ブランチを最新化する方法は主に 2 つあります。

#### 1. `git merge main` の場合

`merge` を使うと、**2 つのブランチの歴史を統合するための新しい「マージコミット」** が作られます。

```bash
## featureブランチで実行
git merge main
```

- 履歴ツリー

```
  A---B---C---F---G (main, feature)
   \             /
    D-----------E
```

> - **メリット**: 誰がいつ合流させたか、という事実が履歴に正確に残る。
> - **デメリット**: プロジェクトが大きくなるとマージコミット（`G`）だらけになり、本筋の変更（`A`から`F`）が追いにくくなる。

#### 2. `git rebase main` の場合

`rebase` を使うと、`feature` ブランチの作業（`D`, `E`）を一旦取り消し、**最新の `main` の先頭に付け直します。**

```bash
## featureブランチで実行
git rebase main
```

- 履歴ツリー

```
  A---B---C---F (main)
               \
                D'--E' (feature)
```

> - **メリット**: 履歴が一直線になり、**プロジェクトの進捗が非常に分かりやすくなる。**
> - **デメリット**: 元のコミット（`D`, `E`）は消え、新しいコミット（`D'`, `E'`）に置き換わるため、「履歴を書き換えた」ことになる。

**結論**

Pull Request を出す前など、**本流に合流させる前のブランチの履歴をきれいに整理したい**場合に `rebase` は非常に有効です。

## 実践ワークフロー：Pull Request 前の `rebase`

最新の `main` ブランチの内容を取り込み、きれいな状態で Pull Request を出すまでの基本的な流れです。

#### 1. リモートの最新情報を取得

```bash
## まずはリモートリポジトリの最新状態を取得する
git fetch origin
```

#### 2. rebase を実行

作業ブランチにいることを確認し、`origin/main` を基点に `rebase` を実行します。

```bash
## featureブランチにいることを確認
git checkout feature/my-task

## origin/main の最新コミットの先に、今のブランチの変更を移動させる
git rebase origin/main
```

#### 3. 💡`pull --rebase` で一発実行

実は、`fetch` と `rebase` は `pull` コマンドで一括実行できます。
作業中（feature/〇〇など）のブランチで実行します。

```bash
git pull --rebase origin main
```

> このコマンドは、「`origin/main` の最新情報を取得し、その上に現在のブランチの変更を `rebase` する」という一連の操作を一度に行います。

## コンフリクト（競合）が発生した場合の対処法

`rebase` 中に、あなたの変更と `main` ブランチの変更が同じファイルの同じ箇所で競合（コンフリクト）することがあります。

> 1.  **コンフリクトしたファイルを修正**
>     Git が教えてくれるファイルを開き、`<<<<<<<`, `=======`, `>>>>>>>` のマーカーを参考に、手動でコードを正しい状態に編集します。

> 2.  **修正をステージングし、rebase を再開**
>     修正が終わったら、ファイルを `git add` でステージングし、`--continue` オプションで `rebase` を再開します。

    ```bash
    git add .
    git rebase --continue
    ```

> 3.  **途中で中止したくなった場合**
>     「手に負えない…！」となったら、`--abort` オプションで `rebase` 開始前の状態に安全に戻せます。

    ```bash
    git rebase --abort
    ```

## 注意点

#### 🚨`rebase` を共有ブランチには使うな！

`rebase` は履歴を書き換えるため、**複数の人が作業している共有ブランチ（例: `main`, `develop`）で実行してはいけません。**

もし共有ブランチの履歴を書き換えて `push` すると、他の人が `pull` しようとした際に履歴の食い違い（Diverged history）が発生し、リポジトリが混乱する原因となります。

`rebase` は、まだ自分しか作業していないローカルのブランチや、Push 済でも自分専用の feature ブランチに対してのみ使いましょう。

#### Push 済みのブランチを `rebase` した場合

自分専用の `feature` ブランチを一度 `push` した後、ローカルで `rebase` を行うと、リモートとローカルの履歴がズレます。このズレを解消し、リモートの履歴をローカルのきれいな履歴で上書きするには、**`force push`（強制プッシュ）** が必要です。

ただし、`git push --force` は非常に危険です。代わりに、より安全な **`--force-with-lease`** を使いましょう。

```bash
## リモートの変更を破壊しないか確認しつつ、安全に強制プッシュ
git push --force-with-lease
```

> `--force-with-lease` は、自分が知らないうちにリモートブランチが更新されていた場合、プッシュを拒否してくれます。これにより、他の人の作業を誤って上書きしてしまうリスクを大幅に減らせます。

## まとめ

| 状況 / やりたいこと                          | 推奨コマンド                          |
| :------------------------------------------- | :------------------------------------ |
| **作業ブランチを最新の main に追従させたい** | `git rebase origin/main`              |
| **fetch と rebase を一度に実行したい**       | `git pull --rebase origin main`       |
| **rebase 中のコンフリクトを解決して続行**    | `git add .` → `git rebase --continue` |
| **rebase を途中で安全に中止したい**          | `git rebase --abort`                  |
| **rebase 後に安全に強制プッシュしたい**      | `git push --force-with-lease`         |

`rebase` は、正しく使えば Git の履歴をクリーンに保ち、チーム開発をスムーズにするための強力なツールです。「自分専用のブランチをきれいにする」というルールを守って、ぜひ活用してみてください。
