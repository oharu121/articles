## TypeScript ユーティリティ型の「王道パターン」まとめ！実務でよく使う型操作テクニック集

## はじめに

TypeScript には便利なユーティリティ型（`Pick`, `Partial`, `Omit`, `Required` など）が用意されていますが、単体ではなく「組み合わせて使う」ことで真価を発揮します。

この記事では、実務でよく使われる 王道の組み合わせパターン 5 選 を紹介します。

**🎯 ベース型の定義（共通）**

まずは、例として使うベース型 User を定義します。

```ts
type User = {
  id: number;
  name: string;
  email: string;
  password: string;
  isAdmin: boolean;
};
```

## 1\. 一部プロパティだけを部分更新可能にする

**💡 レシピ：Partial + Pick**

ユーザー情報の更新フォームを想像してみてください。ユーザーが更新したいのは、name と email だけで、password は変更しないかもしれませんし、id や createdAt は変更できません。このような「特定のプロパティだけを、かつ任意で更新可能にしたい」場合にこのパターンが役立ちます。

```ts
type ProfileUpdate = Partial<Pick<User, "name" | "email" | "password">>;
```

> - まず Pick<User, 'name' | 'email' | 'password'>で更新対象となりうるプロパティを抽出します。
> - 次に Partial<...>で、抽出されたプロパティを全てオプション（任意）にします。
> - フォーム入力のように一部のプロパティのみを任意に更新できるようにしたい場面で使います。

## 2\. 特定プロパティを除いてすべて必須にする

**💡 レシピ：Omit + Required**

Web API のレスポンスや、データベースから取得したデータなど、**「特定の機密情報を除外しつつ、それ以外の必要なデータは必ず存在する」** ことを保証したい場合に有効です。例えば、ユーザー情報を取得する API レスポンスでは、セキュリティの観点から password を含めたくないですよね。

```ts
type SafeUser = Required<Omit<User, "password">>;
```

> - まず Omit<User, 'password'>で password プロパティを除外します。
> - 次に Required<...>で、除外後の全てのプロパティを必須にします。
> - **API レスポンスなどで「パスワードを絶対に含めない」**時に便利。

## 3\. PATCH リクエストのように全プロパティを任意にする

**💡 レシピ：Partial**

HTTP の PATCH リクエストを送信する際のボディの型定義によく使われます。PATCH リクエストは「リソースの一部を更新する」ことが目的のため、リクエストボディ内の全てのフィールドがオプショナルであるべきです。

```ts
type PatchUser = Partial<User>;
```

> - 更新 API（PATCH）のボディでよく使います。
> - すべてのフィールドがオプショナルになります。

## 4\. 管理画面で使う表示用データに加工

**💡 Pick + as const（定義された列名の型に使う）**

管理画面のテーブル表示など、特定のデータセットから「表示に必要なプロパティだけを厳選して抽出したい」場合に、Pick が非常に便利です。さらに、表示するカラム名を配列で管理している場合、その配列から型を自動的に生成することで、表示と型定義の連動性を高めることができます。

```ts
const userTableHeaders = ["id", "name", "email"] as const;
type HeaderKeys = (typeof userTableHeaders)[number];
type UserTableRow = Pick<User, HeaderKeys>;
```

> - 表示したいカラム名を as const で読み取り専用のタプル型として定義します。
> - typeof userTableColumns[number]で、そのタプル内の要素のユニオン型を抽出します（例: 'id' | 'name' | 'email'）。
> - Pick<User, ...>で抽出したユニオン型を使って User 型から必要なプロパティを抽出します。
> - 配列から型を抽出して Pick に使うことで、表示内容と型定義が連動します。

## 5\. API のリクエストとレスポンスで型を分離

**💡 レシピ：Pick + Omit**

API 開発において、クライアントからリクエストされるデータと、サーバーからレスポンスされるデータは、異なるプロパティを持つことがよくあります。特にセキュリティの観点から、リクエスト時には password が必要でも、レスポンスには含めない、といったケースは頻繁です。
このパターンは、Pick と Omit を単体で使うことで、それぞれの用途に特化した型を定義します。

```ts
// 登録用（リクエスト）
type CreateUserRequest = Pick<User, "name" | "email" | "password">;

// 登録後のレスポンス（パスワードは含めない）
type UserResponse = Omit<User, "password">;
```

> - リクエストとレスポンスでフィールドを明確に分離するのは API 開発の基本です。
> - セキュリティ対策としても非常に重要。

**📚 まとめ：ユーティリティ型の組み合わせ一覧**

組み合わせ 目的
Partial<Pick<T, K>> 一部プロパティを部分更新
Required<Omit<T, K>> 特定のプロパティ以外を必須化
Partial<T> 全体を任意プロパティにする
Pick<T, K> 必要なフィールドだけ抽出
Omit<T, K> 除外したいフィールドを外す

## おわりに

型を「継承して再利用」するのではなく、「組み合わせて再構成」できるのが、TypeScript の強力な特徴の一つです。

今回ご紹介した「王道パターン」は、日々の開発で頻繁に遭遇する状況への効果的な解決策です。これらのパターンを覚えることで、あなたの型定義は劇的に改善され、TypeScript がもたらす恩恵を最大限に享受できるでしょう。

ぜひ、今日からこれらのパターンをあなたのコードに取り入れてみてください！
