# TypeScriptユーティリティ型の「王道パターン」まとめ！実務でよく使う型操作テクニック集

# はじめに

TypeScriptには便利なユーティリティ型（`Pick`, `Partial`, `Omit`, `Required` など）が用意されていますが、単体ではなく「組み合わせて使う」ことで真価を発揮します。

この記事では、実務でよく使われる 王道の組み合わせパターン5選 を紹介します。

**🎯 ベース型の定義（共通）**

まずは、例として使うベース型 User を定義します。

```ts
type User = {
  id: number
  name: string
  email: string
  password: string
  isAdmin: boolean
}
```

# 1\. 一部プロパティだけを部分更新可能にする

**💡 レシピ：Partial + Pick**

ユーザー情報の更新フォームを想像してみてください。ユーザーが更新したいのは、nameとemailだけで、passwordは変更しないかもしれませんし、idやcreatedAtは変更できません。このような「特定のプロパティだけを、かつ任意で更新可能にしたい」場合にこのパターンが役立ちます。

```ts
type ProfileUpdate = Partial<Pick<User, 'name' | 'email' | 'password'>>
```

>* まずPick<User, 'name' | 'email' | 'password'>で更新対象となりうるプロパティを抽出します。
>* 次にPartial<...>で、抽出されたプロパティを全てオプション（任意）にします。
>* フォーム入力のように一部のプロパティのみを任意に更新できるようにしたい場面で使います。

# 2\. 特定プロパティを除いてすべて必須にする

**💡 レシピ：Omit + Required**

Web APIのレスポンスや、データベースから取得したデータなど、**「特定の機密情報を除外しつつ、それ以外の必要なデータは必ず存在する」** ことを保証したい場合に有効です。例えば、ユーザー情報を取得するAPIレスポンスでは、セキュリティの観点からpasswordを含めたくないですよね。

```ts
type SafeUser = Required<Omit<User, 'password'>>
```

>* まずOmit<User, 'password'>でpasswordプロパティを除外します。
>* 次にRequired<...>で、除外後の全てのプロパティを必須にします。
>* **APIレスポンスなどで「パスワードを絶対に含めない」**時に便利。

# 3\. PATCHリクエストのように全プロパティを任意にする

**💡 レシピ：Partial**

HTTPのPATCHリクエストを送信する際のボディの型定義によく使われます。PATCHリクエストは「リソースの一部を更新する」ことが目的のため、リクエストボディ内の全てのフィールドがオプショナルであるべきです。

```ts
type PatchUser = Partial<User>
```

>* 更新API（PATCH）のボディでよく使います。
>* すべてのフィールドがオプショナルになります。

# 4\. 管理画面で使う表示用データに加工

**💡 Pick + as const（定義された列名の型に使う）**

管理画面のテーブル表示など、特定のデータセットから「表示に必要なプロパティだけを厳選して抽出したい」場合に、Pickが非常に便利です。さらに、表示するカラム名を配列で管理している場合、その配列から型を自動的に生成することで、表示と型定義の連動性を高めることができます。

```ts
const userTableHeaders = ['id', 'name', 'email'] as const;
type HeaderKeys = typeof userTableHeaders[number];
type UserTableRow = Pick<User, HeaderKeys>;
```

>* 表示したいカラム名をas constで読み取り専用のタプル型として定義します。
>* typeof userTableColumns[number]で、そのタプル内の要素のユニオン型を抽出します（例: 'id' | 'name' | 'email'）。
>* Pick<User, ...>で抽出したユニオン型を使ってUser型から必要なプロパティを抽出します。
>* 配列から型を抽出して Pick に使うことで、表示内容と型定義が連動します。

# 5\. APIのリクエストとレスポンスで型を分離

**💡 レシピ：Pick + Omit**

API開発において、クライアントからリクエストされるデータと、サーバーからレスポンスされるデータは、異なるプロパティを持つことがよくあります。特にセキュリティの観点から、リクエスト時にはpasswordが必要でも、レスポンスには含めない、といったケースは頻繁です。
このパターンは、PickとOmitを単体で使うことで、それぞれの用途に特化した型を定義します。

```ts
// 登録用（リクエスト）
type CreateUserRequest = Pick<User, 'name' | 'email' | 'password'>

// 登録後のレスポンス（パスワードは含めない）
type UserResponse = Omit<User, 'password'>
```

>* リクエストとレスポンスでフィールドを明確に分離するのはAPI開発の基本です。
>* セキュリティ対策としても非常に重要。

**📚 まとめ：ユーティリティ型の組み合わせ一覧**

組み合わせ	目的
Partial<Pick<T, K>>	一部プロパティを部分更新
Required<Omit<T, K>>	特定のプロパティ以外を必須化
Partial<T>	全体を任意プロパティにする
Pick<T, K>	必要なフィールドだけ抽出
Omit<T, K>	除外したいフィールドを外す

# おわりに

型を「継承して再利用」するのではなく、「組み合わせて再構成」できるのが、TypeScriptの強力な特徴の一つです。

今回ご紹介した「王道パターン」は、日々の開発で頻繁に遭遇する状況への効果的な解決策です。これらのパターンを覚えることで、あなたの型定義は劇的に改善され、TypeScriptがもたらす恩恵を最大限に享受できるでしょう。

ぜひ、今日からこれらのパターンをあなたのコードに取り入れてみてください！
